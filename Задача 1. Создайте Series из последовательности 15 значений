1.0.0.1 Task 1. Задание:

Создайте Series из последовательности 15 значений, равномерно разбивающих отрезок [0, 20] (воспользуйтесь функцией linspace) Определите отношение элементов полученной серии к их предыдущим элементам (). В результате необходимо получить среднее полученного вектора, оставив в нём только те значения, которые не более чем 1.5 (*). Выберите из ответов тот, который максимально близок к полученному (c точки зрения абсолютной разницы).

1.0.0.2 Варианты ответов:

1) 1.24
2) 1.18
3) 0.71
4) 1.13 Пояснения: (*) Если было бы необходимо найти последовательность из 3-х значений, равномерно разбивающих отрезок [0,1], то это были бы значения [0, 0.5, 1].
(**) Если был бы дан список элементов a = [1,2,3,12], отношения элементов к предыдущим будут равны [NaN, 2, 1.5, 4]. А на последнем этапе в таком примере останется только [1.5] и среднее значение будет также 1.5.

# создаю последовательность чисел между значениями от 0 до 20, кол вом 15
s = pd.Series(np.linspace(0, 20, 15))
#s.head()
s

0      0.000000
1      1.428571
2      2.857143
3      4.285714
4      5.714286
5      7.142857
6      8.571429
7     10.000000
8     11.428571
9     12.857143
10    14.285714
11    15.714286
12    17.142857
13    18.571429
14    20.000000
dtype: float64

#Передаем в датафрейм
df = pd.DataFrame(s)
# Это датафрейм
df.head()

0
0	0.000000
1	1.428571
2	2.857143
3	4.285714
4	5.714286

df = df.reset_index()
df.head()


index	0
0	0	0.000000
1	1	1.428571
2	2	2.857143
3	3	4.285714
4	4	5.714286

df = df.rename(columns={'index': 'idx'})
df.head()


idx	0
0	0	0.000000
1	1	1.428571
2	2	2.857143
3	3	4.285714
4	4	5.714286

#создал копию df1
df1 = pd.DataFrame(s)
df1.head()

0
0	0.000000
1	1.428571
2	2.857143
3	4.285714
4	5.714286

# дропнул 0 индекс
df1=df1.drop([0])
df1.head()
0
1	1.428571
2	2.857143
3	4.285714
4	5.714286
5	7.142857

#скинул индекс, обязательно два раза, так как с первого раза индекс дублируется, но не начинается с нуля.
df1 = df1.reset_index()
df1.head()

level_0	index	0
0	0	1	1.428571
1	1	2	2.857143
2	2	3	4.285714
3	3	4	5.714286
4	4	5	7.142857

# переипменовал level_0 на idx
df1 = df1.rename(columns={'level_0': 'idx'})
df1.head()


idx	index	0
0	0	1	1.428571
1	1	2	2.857143
2	2	3	4.285714
3	3	4	5.714286
4	4	5	7.142857

job = df.merge(df1, how='left', on='idx')
job.head()
idx	0_x	index	0_y
0	0	0.000000	1.0	1.428571
1	1	1.428571	2.0	2.857143
2	2	2.857143	3.0	4.285714
3	3	4.285714	4.0	5.714286
4	4	5.714286	5.0	7.142857

del job['idx'] #удалить поле
job.head()

0_x	index	0_y
0	0.000000	1.0	1.428571
1	1.428571	2.0	2.857143
2	2.857143	3.0	4.285714
3	4.285714	4.0	5.714286
4	5.714286	5.0	7.142857

del job['index'] #удалить поле
job.head()

0_x	0_y
0	0.000000	1.428571
1	1.428571	2.857143
2	2.857143	4.285714
3	4.285714	5.714286
4	5.714286	7.142857

#Добавляем вычисляемый столбец
job1['itog'] = job['0_y'] / job['0_x']
job1.head()
0_x	0_y	itog
1	1.428571	2.857143	2.000000
2	2.857143	4.285714	1.500000
3	4.285714	5.714286	1.333333
4	5.714286	7.142857	1.250000
5	7.142857	8.571429	1.200000

#Удаляю строку со значением inf, так как она дает ошибку
job1 = job.drop([0])
job1.head()

0_x	0_y
1	1.428571	2.857143
2	2.857143	4.285714
3	4.285714	5.714286
4	5.714286	7.142857
5	7.142857	8.571429

#Получаем и выводим искомое среднее по столбцу itog
mn = job1['itog'].mean()
mn
